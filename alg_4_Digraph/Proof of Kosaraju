命题:有向图g，有向图的反向图gr，当对g在构造函数中使用调用顺序为gr的逆后序的dfs(g,s)时，得到的连通分量一定为强连通分量(Kosaraju算法)
证明:可化为两个命题分别证明:
	命题1：s,v为有向图中的强连通节点，在dfs中，对s的dfs函数调用必定访问v（与s强连通的节点必定出现在dfs(g,s)中）
	证明：反证法
	设dfs(g,s)不会访问到v,因为s->,则v一定已经在dfs(g,s)调用之前被访问过.
	又因为v->s，s暂未被访问，所以在dfs(g,v)时s一定被标记，则不存在dfs(g,s)在构造函数中。
	命题2：dfs(g,s)到达的节点都与s强连通
	证明
	设dfs(g,s)可达v,则s->v,现在只需证明 v->s即可。
	首先若s->v，则在gr中，一定存在v->s，问题转化为证明gr中s->v.
	因为dfs(g,s)在构造函数中按照gr的逆后序遍历，而dfs(g,s)可达v，则dfs(g,v)一定未在dfs(g,s)前调用。所以在gr中，dfs(gr,v)一定先于dfs(gr,s)结束。
	存在两种情况
	1)dfs(gr,v)在dfs(gr,s)前调用
	2)dfs(gr,v)在dfs(gr,s)后调用
	其中1)不存在，因为v->s,若调用dfs(gr,v)一定会触发dfs(gr,s)，而dfs(gr,v)在dfs(gr,s)后结束，与题意不符。
	2)满足题意，可得s->v
	由此可证.

Kosaraju算法是对深度优先搜索连通分量的扩展，问题解决的关键在与选择正确的dfs序列，使得当前节点与后面的节点若可达则必定为强连通，而gr的逆后序正好符合这个规则（gr的逆后序在当前节点只与后面的节点可达，与前面节点可达则必定为强连通）
这也说明无向图的连通分量查找其实是kosraju算法的一个特例，因为无向图任意dfs序列都满足上述规则。
在深度优先搜索连通分量中，每一个连通分量中可能含有强连通也可能含有弱连通，例如s->v,v->s,s->g。Kosaraju的思想就是通过改变循环调用dfs()的顺序
实现把与当前判断连通分量的初始节点相关的弱连通节点去除，使得初始节点通过dfs()可达到的节点均与它强连通。可以证明循环的顺序即为gr的逆后序，
而与初始节点强连通的必定会被收入，因为如果不被收入，只有一个原因：该节点被其他节点收入，而该节点又与初始节点连通，则一定不存在这种节点。
